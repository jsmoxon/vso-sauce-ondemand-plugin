// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
/// <reference path="../definitions/mocha.d.ts"/>
/// <reference path="../definitions/node.d.ts"/>
var assert = require('assert');
var path = require('path');
var util = require('util');
var stream = require('stream');
var shell = require('shelljs');
var os = require('os');
var tl;
var NullStream = function () {
    stream.Writable.call(this);
    this._write = function (data, encoding, next) {
        next();
    };
};
util.inherits(NullStream, stream.Writable);
var StringStream = function () {
    var contents = '';
    stream.Writable.call(this);
    this._write = function (data, encoding, next) {
        contents += data;
        next();
    };
    this.getContents = function () {
        return contents.toString();
    };
};
util.inherits(StringStream, stream.Writable);
var _nullTestStream = new NullStream();
var _mismatch = function (expected, output) {
    return 'expected' + os.EOL + '"' + expected + '"' + os.EOL + 'returned' + os.EOL + '"' + output + '"';
};
var _buildOutput = function (lines) {
    var output = '';
    lines.forEach(function (line) {
        output += line + os.EOL;
    });
    return output;
};
describe('Test vso-task-lib', function () {
    before(function (done) {
        try {
            tl = require('..');
            tl.setStdStream(_nullTestStream);
            tl.setErrStream(_nullTestStream);
        }
        catch (err) {
            assert.fail('Failed to load task lib: ' + err.message);
        }
        done();
    });
    after(function () {
    });
    describe('Dir Operations', function () {
        it('mkdirs', function (done) {
            this.timeout(1000);
            var testFolder = 'testDir';
            var start = __dirname;
            var testPath = path.join(__dirname, testFolder);
            tl.cd(start);
            assert(process.cwd() == start, 'starting in right directory');
            tl.mkdirP(testPath);
            assert(shell.test('-d', testPath), 'directory created');
            tl.pushd(testFolder);
            assert(process.cwd() == testPath, 'cwd is created directory');
            tl.popd(testFolder);
            done();
        });
    });
    describe('TaskInputsVariables', function () {
        it('gets input value', function (done) {
            this.timeout(1000);
            process.env['INPUT_UNITTESTINPUT'] = 'test value';
            var inval = tl.getInput('UnitTestInput', true);
            assert(inval === 'test value', 'reading an input should work');
            done();
        });
        it('invalid input is null', function (done) {
            this.timeout(1000);
            var inval = tl.getInput('SomeInvalidInput', true);
            assert(!inval, 'a non existant input should return null');
            done();
        });
        it('sets and gets a variable', function (done) {
            this.timeout(1000);
            tl.setVariable('UnitTestVariable', 'test var value');
            var varVal = tl.getVariable('UnitTestVariable');
            assert(varVal === 'test var value', 'variable should match after set and get');
            done();
        });
    });
    describe('TaskCommands', function () {
        it('constructs', function (done) {
            this.timeout(1000);
            assert(tl.TaskCommand, 'TaskCommand should be available');
            var tc = new tl.TaskCommand('some.cmd', { foo: 'bar' }, 'a message');
            assert(tc, 'TaskCommand constructor works');
            done();
        });
        it('toStrings', function (done) {
            this.timeout(1000);
            var tc = new tl.TaskCommand('some.cmd', { foo: 'bar' }, 'a message');
            assert(tc, 'TaskCommand constructor works');
            var cmdStr = tc.toString();
            assert(cmdStr === '##vso[some.cmd foo=bar;]a message');
            done();
        });
        it('handles null properties', function (done) {
            this.timeout(1000);
            var tc = new tl.TaskCommand('some.cmd', null, 'a message');
            assert(tc.toString() === '##vso[some.cmd]a message');
            done();
        });
        it('parses cmd with no properties', function (done) {
            var cmdStr = '##vso[basic.command]messageVal';
            var tc = tl.commandFromString(cmdStr);
            assert(tc.command === 'basic.command', 'cmd should be correct');
            assert(Object.keys(tc.properties).length == 0, 'should have no properties.');
            assert(tc.message === 'messageVal', 'message is correct');
            done();
        });
        it('parses basic cmd with values', function (done) {
            var cmdStr = '##vso[basic.command prop1=val1;]messageVal';
            var tc = tl.commandFromString(cmdStr);
            assert(tc.command === 'basic.command', 'cmd should be correct');
            assert(tc.properties['prop1'], 'should be a property names prop1');
            assert(Object.keys(tc.properties).length == 1, 'should have one property.');
            assert(tc.properties['prop1'] === 'val1', 'property value is correct');
            assert(tc.message === 'messageVal', 'message is correct');
            done();
        });
        it('parses basic cmd with multiple properties no trailing semi', function (done) {
            var cmdStr = '##vso[basic.command prop1=val1;prop2=val2]messageVal';
            var tc = tl.commandFromString(cmdStr);
            assert(tc.command === 'basic.command', 'cmd should be correct');
            assert(tc.properties['prop1'], 'should be a property names prop1');
            assert(Object.keys(tc.properties).length == 2, 'should have one property.');
            assert(tc.properties['prop1'] === 'val1', 'property value is correct');
            assert(tc.properties['prop2'] === 'val2', 'property value is correct');
            assert(tc.message === 'messageVal', 'message is correct');
            done();
        });
        it('parses values with spaces in them', function (done) {
            var cmdStr = '##vso[task.setvariable variable=task variable;]task variable set value';
            var tc = tl.commandFromString(cmdStr);
            assert(tc.command === 'task.setvariable', 'cmd should be task.setvariable');
            assert(tc.properties['variable'], 'should be a property names variable');
            assert(tc.properties['variable'] === 'task variable', 'property variable is correct');
            assert(tc.message === 'task variable set value');
            done();
        });
        it('handles empty properties', function (done) {
            this.timeout(1000);
            var tc = new tl.TaskCommand('some.cmd', {}, 'a message');
            console.log(tc.toString());
            assert(tc.toString() === '##vso[some.cmd]a message');
            done();
        });
    });
    describe('TaskLibCommands', function () {
        it('setResult success outputs', function (done) {
            this.timeout(1000);
            var stdStream = new StringStream();
            tl.setStdStream(stdStream);
            tl.setResult(tl.TaskResult.Succeeded, 'success msg');
            var expected = _buildOutput(['##vso[task.debug]task result: Succeeded',
                '##vso[task.complete result=Succeeded;]success msg']);
            var output = stdStream.getContents();
            assert(output === expected, _mismatch(expected, output));
            done();
        });
        it('setResult failed outputs', function (done) {
            this.timeout(1000);
            var stdStream = new StringStream();
            tl.setStdStream(stdStream);
            tl.setResult(tl.TaskResult.Failed, 'failed msg');
            var expected = _buildOutput(['##vso[task.debug]task result: Failed',
                '##vso[task.complete result=Failed;]failed msg']);
            var output = stdStream.getContents();
            assert(output === expected, _mismatch(expected, output));
            done();
        });
        // compat
        it('exit 0 success outputs', function (done) {
            this.timeout(1000);
            var stdStream = new StringStream();
            tl.setStdStream(stdStream);
            tl.exit(0);
            var expected = _buildOutput(['##vso[task.debug]task result: Succeeded',
                '##vso[task.complete result=Succeeded;]return code: 0']);
            var output = stdStream.getContents();
            assert(output === expected, _mismatch(expected, output));
            done();
        });
        it('exit 1 failed outputs', function (done) {
            this.timeout(1000);
            var stdStream = new StringStream();
            tl.setStdStream(stdStream);
            tl.exit(1);
            var expected = _buildOutput(['##vso[task.debug]task result: Failed',
                '##vso[task.complete result=Failed;]return code: 1']);
            var output = stdStream.getContents();
            assert(output === expected, _mismatch(expected, output));
            done();
        });
    });
    describe('ToolRunner', function () {
        it('Execs with stdout', function (done) {
            this.timeout(1000);
            tl.pushd(__dirname);
            var ls = new tl.ToolRunner(tl.which('ls', true));
            ls.arg('-l');
            ls.arg('-a');
            var output = '';
            ls.on('stdout', function (data) {
                output = data.toString();
            });
            ls.exec({ outStream: _nullTestStream, errStream: _nullTestStream })
                .then(function (code) {
                assert(code === 0, 'return code of ls should be 0');
                assert(output && output.length > 0, 'should have emitted stdout');
            })
                .fail(function (err) {
                assert.fail('ls failed to run: ' + err.message);
            })
                .fin(function () {
                tl.popd();
                done();
            });
        });
        it('Fails on return code 1 with stderr', function (done) {
            this.timeout(1000);
            var failed = false;
            var ls = new tl.ToolRunner(tl.which('ls', true));
            ls.arg('-j');
            var output = '';
            ls.on('stderr', function (data) {
                output = data.toString();
            });
            ls.exec({ outStream: _nullTestStream, errStream: _nullTestStream })
                .then(function (code) {
                assert(code === 1, 'return code of ls -j should be 1');
                assert(output && output.length > 0, 'should have emitted stderr');
            })
                .fail(function (err) {
                failed = true;
            })
                .fin(function () {
                if (!failed) {
                    done(new Error('ls should have failed'));
                    return;
                }
                done();
            });
        });
        it('Succeeds on stderr by default', function (done) {
            this.timeout(1000);
            var scriptPath = path.join(__dirname, 'scripts', 'stderroutput.js');
            var ls = new tl.ToolRunner(tl.which('node', true));
            ls.arg(scriptPath);
            ls.exec({ outStream: _nullTestStream, errStream: _nullTestStream })
                .then(function (code) {
                assert(code === 0, 'should have succeeded on stderr');
                done();
            })
                .fail(function (err) {
                done(new Error('did not succeed on stderr'));
            });
        });
        it('Fails on stderr if specified', function (done) {
            this.timeout(1000);
            var failed = false;
            var scriptPath = path.join(__dirname, 'scripts', 'stderrOutput.js');
            var ls = new tl.ToolRunner(tl.which('node', true));
            ls.arg(scriptPath);
            ls.exec({ failOnStdErr: true, outStream: _nullTestStream, errStream: _nullTestStream })
                .then(function (code) {
                assert(code === 0, 'should have succeeded on stderr');
            })
                .fail(function (err) {
                failed = true;
            })
                .fin(function () {
                if (!failed) {
                    done(new Error('should have failed on stderr'));
                    return;
                }
                done();
            });
        });
        it('handles single args', function (done) {
            this.timeout(1000);
            var node = new tl.ToolRunner(tl.which('node', true));
            node.arg('one');
            node.arg('two');
            assert(node.args.length === 2, 'should have 2 args');
            assert(node.args.toString() === 'one,two', 'should be one,two');
            done();
        });
        it('handles basic arg line with spaces', function (done) {
            this.timeout(1000);
            var node = new tl.ToolRunner(tl.which('node', true));
            node.arg('one two');
            node.arg('three');
            assert(node.args.length === 3, 'should have 3 args');
            assert(node.args.toString() === 'one,two,three', 'should be one,two,three');
            done();
        });
        it('handles equals and switches', function (done) {
            this.timeout(1000);
            var node = new tl.ToolRunner(tl.which('node', true));
            node.arg('foo=bar -x');
            node.arg('-y');
            assert(node.args.length === 3, 'should have 3 args');
            assert(node.args.toString() === 'foo=bar,-x,-y', 'should be foo=bar,-x,-y');
            done();
        });
        it('handles double quotes', function (done) {
            this.timeout(1000);
            var node = new tl.ToolRunner(tl.which('node', true));
            node.arg('foo="bar baz" -x');
            node.arg('-y');
            assert(node.args.length === 3, 'should have 3 args');
            assert(node.args.toString() === 'foo=bar baz,-x,-y', 'should be foo=bar baz,-x,-y');
            done();
        });
    });
});
